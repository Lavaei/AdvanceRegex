{"version":3,"sources":["multiRegExp2.js"],"names":[],"mappings":"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","file":"multiRegExp2-compiled.js","sourcesContent":["/**\n * Created by velten on 11.02.17.\n */\n\n/**\n * Adds brackets before and after a part of string\n * @param str string the hole regex string\n * @param start int marks the position where ( should be inserted\n * @param end int marks the position where ) should be inserted\n * @param groupsAdded int defines the offset to the original string because of inserted brackets\n * @return {string}\n */\n\nfunction addGroupToRegexString(str, start, end, groupsAdded) {\n\tstart += groupsAdded*2;\n\tend += groupsAdded*2;\n\treturn str.substring(0, start) + '(' + str.substring(start, end + 1) + ')' + str.substring(end + 1);\n}\n\n/**\n * converts the given regex to a regex where all not captured string are going to be captured\n * it along sides generates a mapper which maps the original group index to the shifted group offset and\n * generates a list of groups indexes (including new generated capturing groups)\n * which have been closed before a given group index (unshifted)\n *\n * Example:\n * regexp: /a(?: )bc(def(ghi)xyz)/g => /(a(?: )bc)((def)(ghi)(xyz))/g\n * groupIndexMapper: {'1': 2, '2', 4}\n * previousGroupsForGroup: {'1': [1], '2': [1, 3]}\n *\n * @param regex RegExp\n * @return {{regexp: RegExp, groupIndexMapper: {}, previousGroupsForGroup: {}}}\n */\nfunction fillGroups(regex) {\n\tconst regexString = regex.toString();\n\tconst tester = /(\\(\\?)|(\\()|([^\\\\]\\))/g; // regexp is greedy so it should match (? before ( right?\n\n\tconst modifier = regexString.substring(regexString.lastIndexOf(regexString[0])+1);\n\tconst strippedString = regexString.substr(1, regexString.lastIndexOf(regexString[0])-1);\n\tlet modifiedRegex = strippedString;\n\n\tlet lastGroupStartPosition = -1;\n\tlet lastGroupEndPosition = -1;\n\tlet groupsAdded = 0;\n\tlet groupCount = 0;\n\tlet matchArr;\n\tconst nonGroupPositions = [];\n\tconst groupPositions = [];\n\tconst groupNumber = [];\n\tconst currentLengthIndexes = [];\n\tconst groupIndexMapper = {};\n\tconst previousGroupsForGroup = {};\n\twhile ((matchArr = tester.exec(strippedString)) !== null ) {\n\t\tif(matchArr[1]) { // non capturing group\n\t\t\tnonGroupPositions.push(matchArr.index);\n\t\t}\n\t\telse if(matchArr[2]) { // capturing group\n\t\t\tlet index = matchArr.index;\n\t\t\tlet lastGroupPosition = Math.max(lastGroupStartPosition, lastGroupEndPosition);\n\t\t\tif(lastGroupPosition < index - 1) {\n\t\t\t\tmodifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupPosition + 1, index - 1, groupsAdded);\n\t\t\t\tgroupsAdded++;\n\t\t\t\tlastGroupEndPosition = index - 1; // imaginary position as it is not in regex but modifiedRegex\n\t\t\t\tcurrentLengthIndexes.push(groupCount + groupsAdded);\n\t\t\t}\n\n\t\t\tgroupCount++;\n\t\t\tlastGroupStartPosition = index;\n\t\t\tgroupPositions.push(index);\n\t\t\tgroupNumber.push(groupCount + groupsAdded);\n\t\t\tgroupIndexMapper[groupCount] = groupCount + groupsAdded;\n\t\t\tpreviousGroupsForGroup[groupCount] = currentLengthIndexes.slice();\n\t\t}\n\t\telse if(matchArr[3]) { // closing bracket\n\t\t\tif( (groupPositions.length && !nonGroupPositions.length) ||\n\t\t\t\tgroupPositions[groupPositions.length-1] > nonGroupPositions[nonGroupPositions.length-1]\n\t\t\t) {\n\t\t\t\tlet index = matchArr.index + 1; // +1 as second character of regexp is closing bracket\n\t\t\t\tif(lastGroupStartPosition < lastGroupEndPosition && lastGroupEndPosition < index - 1) {\n\t\t\t\t\tmodifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupEndPosition + 1, index - 1, groupsAdded);\n\t\t\t\t\tgroupsAdded++;\n\t\t\t\t\t//lastGroupEndPosition = matchArr.index - 1; will be set anyway\n\t\t\t\t\tcurrentLengthIndexes.push(groupCount + groupsAdded);\n\t\t\t\t}\n\n\t\t\t\tgroupPositions.pop();\n\t\t\t\tlastGroupEndPosition = index;\n\t\t\t\tcurrentLengthIndexes.push(groupNumber.pop());\n\t\t\t}\n\t\t\telse if(nonGroupPositions.length) {\n\t\t\t\tnonGroupPositions.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {regexp: new RegExp(modifiedRegex, modifier), groupIndexMapper, previousGroupsForGroup};\n}\n\nfunction MultiRegExp2(baseRegExp) {\n\tlet filled = fillGroups(baseRegExp);\n\tthis.regexp = filled.regexp;\n\tthis.groupIndexMapper = filled.groupIndexMapper;\n\tthis.previousGroupsForGroup = filled.previousGroupsForGroup;\n}\n\nMultiRegExp2.prototype = new RegExp();\nMultiRegExp2.prototype.execForAllGroups = function(string) {\n\tlet matches = RegExp.prototype.exec.call(this.regexp, string);\n\tif(!matches) return matches;\n\tlet firstIndex = matches.index;\n\n\treturn Object.keys(this.groupIndexMapper).map((group) => {\n\t\tlet mapped = this.groupIndexMapper[group];\n\t\tlet r = {\n\t\t\tmatch:  matches[mapped],\n\t\t\tstart:  firstIndex + this.previousGroupsForGroup[group].reduce((sum, i) => sum + matches[i].length, 0),\n\t\t};\n\t\tr.end = r.start + matches[mapped].length - 1;\n\n\t\treturn r;\n\t});\n};\nMultiRegExp2.prototype.execForGroup = function(string, group) {\n\tlet matches = RegExp.prototype.exec.call(this.regexp, string);\n\tif(!matches) return matches;\n\tlet firstIndex = matches.index;\n\n\tlet mapped = this.groupIndexMapper[group];\n\tlet r = {\n\t\tmatch:  matches[mapped],\n\t\tstart:  firstIndex + this.previousGroupsForGroup[group].reduce((sum, i) => sum + matches[i].length, 0),\n\t};\n\tr.end = r.start + matches[mapped].length - 1;\n\n\treturn r;\n};\n"]}