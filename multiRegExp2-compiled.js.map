{"version":3,"sources":["multiRegExp2.js"],"names":[],"mappings":"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","file":"multiRegExp2-compiled.js","sourcesContent":["/**\n * Created by velten on 11.02.17.\n */\n\n/**\n * Adds brackets before and after a part of string\n * @param str string the hole regex string\n * @param start int marks the position where ( should be inserted\n * @param end int marks the position where ) should be inserted\n * @param groupsAdded int defines the offset to the original string because of inserted brackets\n * @return {string}\n */\n\nfunction addGroupToRegexString(str, start, end, groupsAdded) {\n  start += groupsAdded * 2;\n  end += groupsAdded * 2;\n  return str.substring(0, start) + '(' + str.substring(start, end + 1) + ')' + str.substring(end + 1);\n}\n\n/**\n *\n * @param position\n * @return {boolean}\n */\nfunction isEscaped(position) {\n  let count = 0;\n  for (let i = position - 1; i >= 0; i--) {\n    if (regexString.substr(i, 1) != \"\\\\\") break;\n    count++;\n  }\n  return count != 0 && count % 2 == 1;\n}\n\n/**\n *\n * @param position\n * @return {boolean}\n */\nfunction isInCharacterSets(position) {\n  for (let i = position - 1; i >= 0; i--) {\n    if (regexString.substr(i, 1) == \"]\" && !isEscaped(i)) return false;\n    if (regexString.substr(i, 1) == \"[\" && !isEscaped(i)) return true;\n  }\n  return false;\n}\n\n/**\n * converts the given regex to a regex where all not captured string are going to be captured\n * it along sides generates a mapper which maps the original group index to the shifted group offset and\n * generates a list of groups indexes (including new generated capturing groups)\n * which have been closed before a given group index (unshifted)\n *\n * Example:\n * regexp: /a(?: )bc(def(ghi)xyz)/g => /(a(?: )bc)((def)(ghi)(xyz))/g\n * groupIndexMapper: {'1': 2, '2', 4}\n * previousGroupsForGroup: {'1': [1], '2': [1, 3]}\n *\n * @param regex RegExp\n * @return {{regexp: RegExp, groupIndexMapper: {}, previousGroupsForGroup: {}}}\n */\nfunction fillGroups(regex) {\n  let regexString;\n  let modifier;\n  if (regex.source && regex.flags) {\n    regexString = regex.source;\n    modifier = regex.flags;\n  }\n  else {\n    regexString = regex.toString();\n    modifier = regexString.substring(regexString.lastIndexOf(regexString[0]) + 1); // sometimes order matters ;)\n    regexString = regexString.substr(1, regex.toString().lastIndexOf(regexString[0]) - 1);\n  }\n  // regexp is greedy so it should match (? before ( right?\n  // brackets may be not quoted by \\\n  // closing bracket may look like: ), )+, )+?, ){1,}?, ){1,1111}?\n  const tester = /(\\(\\?)|(\\()|(\\)(?:\\{\\d+,?\\d*}|[*+?])?\\??)/g;\n\n  let modifiedRegex = regexString;\n\n  let lastGroupStartPosition = -1;\n  let lastGroupEndPosition = -1;\n  let groupsAdded = 0;\n  let groupCount = 0;\n  let matchArr;\n  const nonGroupPositions = [];\n  const groupPositions = [];\n  const groupNumber = [];\n  const currentLengthIndexes = [];\n  const groupIndexMapper = {};\n  const previousGroupsForGroup = {};\n  while ((matchArr = tester.exec(regexString)) !== null) {\n    if (isEscaped(regexString, matchArr.index) || isInCharacterSets(regexString, matchArr.index)) continue;\n    if (matchArr[1]) { // non capturing group\n      let index = matchArr.index + matchArr[0].length - 1;\n      nonGroupPositions.push(index);\n    }\n    else if (matchArr[2]) { // capturing group\n      let index = matchArr.index + matchArr[0].length - 1;\n      let lastGroupPosition = Math.max(lastGroupStartPosition, lastGroupEndPosition);\n\n      if (lastGroupPosition < index - 1) {\n        modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupPosition + 1, index - 1, groupsAdded);\n        groupsAdded++;\n        lastGroupEndPosition = index - 1; // imaginary position as it is not in regex but modifiedRegex\n        currentLengthIndexes.push(groupCount + groupsAdded);\n      }\n\n      groupCount++;\n      lastGroupStartPosition = index;\n      groupPositions.push(index);\n      groupNumber.push(groupCount + groupsAdded);\n      groupIndexMapper[groupCount] = groupCount + groupsAdded;\n      previousGroupsForGroup[groupCount] = currentLengthIndexes.slice();\n    }\n    else if (matchArr[3]) { // closing bracket\n      let index = matchArr.index + matchArr[0].length - 1;\n\n      if ((groupPositions.length && !nonGroupPositions.length) ||\n        groupPositions[groupPositions.length - 1] > nonGroupPositions[nonGroupPositions.length - 1]\n      ) {\n        if (lastGroupStartPosition < lastGroupEndPosition && lastGroupEndPosition < index - 1) {\n          modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupEndPosition + 1, index - 1, groupsAdded);\n          groupsAdded++;\n          //lastGroupEndPosition = index - 1; will be set anyway\n          currentLengthIndexes.push(groupCount + groupsAdded);\n        }\n\n        groupPositions.pop();\n        lastGroupEndPosition = index;\n        currentLengthIndexes.push(groupNumber.pop());\n      }\n      else if (nonGroupPositions.length) {\n        nonGroupPositions.pop();\n      }\n    }\n  }\n\n  return {regexp: new RegExp(modifiedRegex, modifier), groupIndexMapper, previousGroupsForGroup};\n}\n\nexport default class MultiRegExp2 {\n  constructor(baseRegExp) {\n    const {regexp, groupIndexMapper, previousGroupsForGroup} = fillGroups(baseRegExp);\n    this.regexp = regexp;\n    this.groupIndexMapper = groupIndexMapper;\n    this.previousGroupsForGroup = previousGroupsForGroup;\n  }\n\n  execForAllGroups(string, includeFullMatch) {\n    let matches = RegExp.prototype.exec.call(this.regexp, string);\n    if (!matches) return matches;\n    let firstIndex = matches.index;\n    let indexMapper = includeFullMatch ? this.groupIndexMapper : Object.assign({0: 0}, this.groupIndexMapper);\n    let previousGroups = includeFullMatch ? this.previousGroupsForGroup : Object.assign({0: []}, this.previousGroupsForGroup);\n\n    return Object.keys(indexMapper).map((group) => {\n      let mapped = indexMapper[group];\n      let r = {\n        match: matches[mapped],\n        start: firstIndex + previousGroups[group].reduce(\n          (sum, i) => sum + (matches[i] ? matches[i].length : 0), 0\n        )\n      };\n      r.end = r.start + (matches[mapped] ? matches[mapped].length : 0);\n\n      return r;\n    });\n  }\n\n  execForGroup(string, group) {\n    const matches = RegExp.prototype.exec.call(this.regexp, string);\n    if (!matches) return matches;\n    const firstIndex = matches.index;\n\n    const mapped = group == 0 ? 0 : this.groupIndexMapper[group];\n    const previousGroups = group == 0 ? [] : this.previousGroupsForGroup[group];\n    let r = {\n      match: matches[mapped],\n      start: firstIndex + previousGroups.reduce(\n        (sum, i) => sum + (matches[i] ? matches[i].length : 0), 0\n      )\n    };\n    r.end = r.start + (matches[mapped] ? matches[mapped].length : 0);\n\n    return r;\n  }\n}"]}