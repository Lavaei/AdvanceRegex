{"version":3,"file":"multiRegExp2.iife.js","sources":["../src/multiRegExp2.js"],"sourcesContent":["/**\n * Created by velten on 11.02.17.\n */\n\n/**\n * Adds brackets before and after a part of string\n * @param str string the hole regex string\n * @param start int marks the position where ( should be inserted\n * @param end int marks the position where ) should be inserted\n * @param groupsAdded int defines the offset to the original string because of inserted brackets\n * @return {string}\n */\nfunction addGroupToRegexString(str, start, end, groupsAdded) {\n  start += groupsAdded * 2;\n  end += groupsAdded * 2;\n  return str.substring(0, start) + '(' + str.substring(start, end + 1) + ')' + str.substring(end + 1);\n}\n\n/**\n * converts the given regex to a regex where all not captured string are going to be captured\n * it along sides generates a mapper which maps the original group index to the shifted group offset and\n * generates a list of groups indexes (including new generated capturing groups)\n * which have been closed before a given group index (unshifted)\n *\n * Example:\n * regexp: /a(?: )bc(def(ghi)xyz)/g => /(a(?: )bc)((def)(ghi)(xyz))/g\n * groupIndexMapper: {'1': 2, '2', 4}\n * previousGroupsForGroup: {'1': [1], '2': [1, 3]}\n *\n * @param regex RegExp\n * @return {{regexp: RegExp, groupIndexMapper: {}, previousGroupsForGroup: {}}}\n */\nfunction fillGroups(regex) {\n  let regexString;\n  let modifier;\n  if (regex.source && regex.flags) {\n    regexString = regex.source;\n    modifier = regex.flags;\n  }\n  else {\n    regexString = regex.toString();\n    modifier = regexString.substring(regexString.lastIndexOf(regexString[0]) + 1); // sometimes order matters ;)\n    regexString = regexString.substr(1, regex.toString().lastIndexOf(regexString[0]) - 1);\n  }\n  // regexp is greedy so it should match (? before ( right?\n  // brackets may be not quoted by \\\n  // closing bracket may look like: ), )+, )+?, ){1,}?, ){1,1111}?\n\tconst tester = /(\\\\\\()|(\\\\\\))|(\\(\\?)|(\\()|(\\)(?:\\{\\d+,?\\d*}|[*+?])?\\??)/g;\n\n  let modifiedRegex = regexString;\n\n  let lastGroupStartPosition = -1;\n  let lastGroupEndPosition = -1;\n  let lastNonGroupStartPosition = -1;\n  let lastNonGroupEndPosition = -1;\n  let groupsAdded = 0;\n  let groupCount = 0;\n  let matchArr;\n  const nonGroupPositions = [];\n  const groupPositions = [];\n  const groupNumber = [];\n  let currentLengthIndexes = [];\n  const groupIndexMapper = {};\n  const previousGroupsForGroup = {};\n  while ((matchArr = tester.exec(regexString)) !== null) {\n    if(matchArr[1] || matchArr[2]) { // ignore escaped brackets \\(, \\)\n\n    }\n    if (matchArr[3]) { // non capturing group (?\n      let index = matchArr.index + matchArr[0].length - 1;\n\n      lastNonGroupStartPosition = index;\n      nonGroupPositions.push(index);\n    }\n    else if (matchArr[4]) { // capturing group (\n      let index = matchArr.index + matchArr[0].length - 1;\n\n      let lastGroupPosition = Math.max(lastGroupStartPosition, lastGroupEndPosition);\n\n      // if a (? is found add ) before it\n      if(lastNonGroupStartPosition > lastGroupPosition) {\n        // check if between ) of capturing group lies a non capturing group\n        if(lastGroupPosition < lastNonGroupEndPosition) {\n          // add groups for x1 and x2 on (?:()x1)x2(?:...\n          if((lastNonGroupEndPosition - 1) - (lastGroupPosition + 1) > 0) {\n            modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupPosition + 1, lastNonGroupEndPosition - 1, groupsAdded);\n            groupsAdded++;\n            lastGroupEndPosition = lastNonGroupEndPosition - 1; // imaginary position as it is not in regex but modifiedRegex\n            currentLengthIndexes.push(groupCount + groupsAdded);\n          }\n\n          if((lastNonGroupStartPosition - 1) - (lastNonGroupEndPosition + 1) > 0) {\n            modifiedRegex = addGroupToRegexString(modifiedRegex, lastNonGroupEndPosition + 1, lastNonGroupStartPosition - 2, groupsAdded);\n            groupsAdded++;\n            lastGroupEndPosition = lastNonGroupStartPosition - 1; // imaginary position as it is not in regex but modifiedRegex\n            currentLengthIndexes.push(groupCount + groupsAdded);\n          }\n        }\n        else {\n          modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupPosition + 1, lastNonGroupStartPosition - 2, groupsAdded);\n          groupsAdded++;\n          lastGroupEndPosition = lastNonGroupStartPosition - 1; // imaginary position as it is not in regex but modifiedRegex\n          currentLengthIndexes.push(groupCount + groupsAdded);\n        }\n\n        // if necessary also add group between (? and opening bracket\n        if(index > lastNonGroupStartPosition + 2) {\n          modifiedRegex = addGroupToRegexString(modifiedRegex, lastNonGroupStartPosition + 2, index - 1, groupsAdded);\n          groupsAdded++;\n          lastGroupEndPosition = index - 1; // imaginary position as it is not in regex but modifiedRegex\n          currentLengthIndexes.push(groupCount + groupsAdded);\n        }\n      }\n      else if (lastGroupPosition < index - 1) {\n        modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupPosition + 1, index - 1, groupsAdded);\n        groupsAdded++;\n        lastGroupEndPosition = index - 1; // imaginary position as it is not in regex but modifiedRegex\n        currentLengthIndexes.push(groupCount + groupsAdded);\n      }\n\n      groupCount++;\n      lastGroupStartPosition = index;\n      groupPositions.push(index);\n      groupNumber.push(groupCount + groupsAdded);\n      groupIndexMapper[groupCount] = groupCount + groupsAdded;\n      previousGroupsForGroup[groupCount] = currentLengthIndexes.slice();\n    }\n    else if (matchArr[5]) { // closing bracket ), )+, )+?, ){1,}?, ){1,1111}?\n      let index = matchArr.index + matchArr[0].length - 1;\n\n      if ((groupPositions.length && !nonGroupPositions.length) ||\n        groupPositions[groupPositions.length - 1] > nonGroupPositions[nonGroupPositions.length - 1]\n      ) {\n        if (lastGroupStartPosition < lastGroupEndPosition && lastGroupEndPosition < index - 1) {\n          modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupEndPosition + 1, index - 1, groupsAdded);\n          groupsAdded++;\n          //lastGroupEndPosition = index - 1; will be set anyway\n          currentLengthIndexes.push(groupCount + groupsAdded);\n        }\n\n        groupPositions.pop();\n        lastGroupEndPosition = index;\n\n        let toPush = groupNumber.pop();\n        currentLengthIndexes.push(toPush);\n        currentLengthIndexes = currentLengthIndexes.filter(index => index <= toPush);\n      }\n      else if (nonGroupPositions.length) {\n        nonGroupPositions.pop();\n        lastNonGroupEndPosition = index;\n      }\n    }\n  }\n\n  return {regexp: new RegExp(modifiedRegex, modifier), groupIndexMapper, previousGroupsForGroup};\n}\n\nexport default class MultiRegExp2 {\n  constructor(baseRegExp) {\n    const {regexp, groupIndexMapper, previousGroupsForGroup} = fillGroups(baseRegExp);\n    this.regexp = regexp;\n    this.groupIndexMapper = groupIndexMapper;\n    this.previousGroupsForGroup = previousGroupsForGroup;\n  }\n\n  execForAllGroups(string, includeFullMatch) {\n    let matches = RegExp.prototype.exec.call(this.regexp, string);\n    if (!matches) return matches;\n    let firstIndex = matches.index;\n    let indexMapper = includeFullMatch ? Object.assign({0: 0}, this.groupIndexMapper) : this.groupIndexMapper;\n    let previousGroups = includeFullMatch ? Object.assign({0: []}, this.previousGroupsForGroup) : this.previousGroupsForGroup;\n\n    return Object.keys(indexMapper).map((group) => {\n      let mapped = indexMapper[group];\n      let r = {\n        match: matches[mapped],\n        start: firstIndex + previousGroups[group].reduce(\n          (sum, i) => sum + (matches[i] ? matches[i].length : 0), 0\n        )\n      };\n      r.end = r.start + (matches[mapped] ? matches[mapped].length : 0);\n\n      return r;\n    });\n  }\n\n  execForGroup(string, group) {\n    const matches = RegExp.prototype.exec.call(this.regexp, string);\n    if (!matches) return matches;\n    const firstIndex = matches.index;\n\n    const mapped = group == 0 ? 0 : this.groupIndexMapper[group];\n    const previousGroups = group == 0 ? [] : this.previousGroupsForGroup[group];\n    let r = {\n      match: matches[mapped],\n      start: firstIndex + previousGroups.reduce(\n        (sum, i) => sum + (matches[i] ? matches[i].length : 0), 0\n      )\n    };\n    r.end = r.start + (matches[mapped] ? matches[mapped].length : 0);\n\n    return r;\n  }\n}\n"],"names":[],"mappings":"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"}